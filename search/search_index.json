{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Projects","text":""},{"location":"#projects","title":"Projects","text":""},{"location":"#mangaloid","title":"Mangaloid","text":"<p> Kotlin \u2002 361 commits \u2002 Last commit on Sep 15th, 2024</p>"},{"location":"#busted","title":"Busted","text":"<p> Kotlin \u2002 484 commits \u2002 Last commit on Aug 24th, 2024</p>"},{"location":"#progress","title":"Progress","text":"<p> Kotlin \u2002 470 commits \u2002 Last commit on Dec 3rd, 2023</p>"},{"location":"#tweedle-for-twitter","title":"Tweedle for Twitter","text":"<p> Java \u2002 3,818 commits \u2002 Last commit on Sep 15th, 2017</p>"},{"location":"#movies-tv","title":"Movies &amp; TV","text":"<p> Java \u2002 471 commits \u2002 Last commit on Nov 7th, 2015</p>"},{"location":"#ingress-personal-assistant","title":"Ingress Personal Assistant","text":"<p> Java \u2002 620 commits \u2002 Last commit on Sep 16th, 2014</p>"},{"location":"learnings/2024-08-25-dynamic-app-icons/","title":"Dynamic launcher icons","text":"<p>Have you ever wanted to swap your Android app's icon at runtime? It could be useful as a premium feature or as a way for your users to customize the feel of your application. I have a solution that works for the most part, with some drawbacks that will need to be weighed before implementing it into your application.</p> <p>Starting off this is the exact same method seen in applications such as Discord or Todoist. The main drawback is that the first time we enable this new behavior your application will be closed automatically as your new icon is applied. Subsequent calls to reset or switch to any other icons will not result in your application closing. This is undefined behavior, and I have no workaround for it. If that is fine, let's get into the weeds.</p>"},{"location":"learnings/2024-08-25-dynamic-app-icons/#activity-alias","title":"Activity alias","text":"<p>Traditionally I have only ever used an activity-alias to redirect my launching activity reference when I have moved the actual class into a new package. We are going to be leveraging that concept to not only redirect once to our launching activity, but many times depending on how many icons you want. The catch is that by default only one of those should be enabled. That way you can at runtime switch between them by enabling and disabling aliases, resulting in the perception of the icon changing to the user.</p> <pre><code>&lt;application  \n    android:label=\"@string/app_name\"  \n    android:icon=\"@mipmap/ic_launcher\"&gt;\n    &lt;activity\n        android:name=\".MainActivity\"\n        android:exported=\"true\"&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=\"android.intent.action.MAIN\" /&gt;  \n        &lt;/intent-filter&gt;\n    &lt;/activity&gt;\n    &lt;activity-alias\n        android:name=\".AliasDefault\"  \n        android:enabled=\"true\"  \n        android:exported=\"true\"\n        android:targetActivity=\".MainActivity\"&gt;  \n        &lt;intent-filter&gt;\n            &lt;action android:name=\"android.intent.action.MAIN\" /&gt;  \n            &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;  \n        &lt;/intent-filter&gt;\n    &lt;/activity-alias&gt;\n    &lt;activity-alias\n        android:name=\".AliasAlternative\"  \n        android:enabled=\"false\"  \n        android:exported=\"true\"\n        android:icon=\"@mipmap/ic_launcher_alternative\"\n        android:targetActivity=\".MainActivity\"&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=\"android.intent.action.MAIN\" /&gt;  \n            &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;  \n        &lt;/intent-filter&gt;\n    &lt;/activity-alias&gt; \n&lt;/application&gt;\n</code></pre>"},{"location":"learnings/2024-08-25-dynamic-app-icons/#into-the-weeds","title":"Into the weeds","text":"<p>The initial implementation of the activity-alias only showcases a single enabled alias, and a disabled one with an alternative icon applied. This concept does work for more than one disabled alias and can even extend to change the title of your application as well. Digging a bit further we need to understand how we can safely switch between those aliases without impacting our users negatively.</p> <p>The way we reference an activity-alias in code is via a class called <code>ComponentName</code>, for example the equivalent of the enabled alias above is <code>ComponentName(pkg, \"$pkg.AliasDefault\")</code>. This is used when communicating with the <code>PackageManager</code> class, specifically we want to use it when calling <code>getComponentEnabledSetting</code> and <code>setComponentEnabledSetting</code>.</p> <p>At a high level we need to be able to not only enable the currently disabled alias, but also disable the currently enabled alias. If we blindly switch the states it will work, but your application will close automatically every single time you do. If you only want it to happen the first time you need to take into account the original default state. So when enabling the default alias, you just need to set the state to default. Or when disabling the non-default alias, you just need to set the state to default.</p> <p>I have compiled an example project that does all of this that you can follow as a guide, or just copy/paste it like most do from StackOverflow. I don't mind either way, it is a pretty slick solution once it is in place. Given this is largely in uncharted territories, good luck if you ship it to production.</p>"},{"location":"learnings/2024-08-25-dynamic-app-icons/#example-project-in-action","title":"Example project in action","text":""},{"location":"learnings/2024-09-29-modules/","title":"Woes of success: Android modules","text":"<p>Android applications start out typically in a monolith design. One module for all project logic with ease of access for quick iteration. If your project is very successful, you might eventually run into a few issues. The most obvious one would be that your build times will start to creep up. With all of your code in one module, the build cache will rebuild the whole project upon any change. The more subtle issue is around maintainability. As you have no strict boundaries, it is easy for concessions to be made and things slowly start getting tightly coupled together.</p> <p>I'm sure given enough time we could come up with a host of other problems or try to explain away how in your particular case this isn't a problem, but here me out for a moment. Speaking from my own experience those problems do happen and when they do it can be difficult to even know where to start. Do I just start splitting the monolith up into modules? How do I do that in a way that isn't just kicking the can down the road? Has this problem been solved before?</p>"},{"location":"learnings/2024-09-29-modules/#abstraction-and-encapsulation","title":"Abstraction and Encapsulation","text":""},{"location":"learnings/2024-09-29-modules/#web-services","title":"Web services","text":"<p>One of the most common things we interact with outside of our projects are web services. Typically we connect and leverage them through common protocols like JSON or Protobuf, with strong API contracts defined per service. This tells us exactly how we should interact with them, and what is and what is not allowed. Using this as an example, we can look at our usage of them kind of like this:</p> <p> </p>"},{"location":"learnings/2024-09-29-modules/#interfaces","title":"Interfaces","text":"<p>A common pattern is the usage of a style of class called an interface. It allows us to easily define what exact behavior of a class is, without referencing the class itself. This can be useful for cases where we want to abstract out the implementation from the consumer of the class, or if we want to be able to switch out the implementation itself without impacting the consumer. Lots of good reasons to use an interface exist, but we can also simplify it down to something like this:</p> <p> </p>"},{"location":"learnings/2024-09-29-modules/#modules","title":"Modules","text":""},{"location":"learnings/2024-09-29-modules/#standing-on-the-shoulders-of-giants","title":"Standing on the shoulders of giants","text":"<p>The examples shown above highlight a commonality seen across domains. Using an abstraction, we are able to scope behavior and easily maintain our business logic. This can be adapted to our own problem. If we break up our code such that we define a single unit into both a contract and an implementation, it can be accessed without needing to pulling in the whole implementation.</p> <p> </p>"},{"location":"learnings/2024-09-29-modules/#build-cache","title":"Build cache","text":"<p>The ramifications to breaking up your code like this, is that only your contracts are references by consuming code. This allows the build cache to only need to rebuild what has been changed. For example if you adjusted an implementation of a given unit, the callers wouldn't need to be rebuilt. They only accessed it via the interface so nothing changed for them.</p>"},{"location":"learnings/2024-09-29-modules/#maintainability","title":"Maintainability","text":"<p>Since we are now enforcing the access of business logic via contract it makes it much harder to intermingle across boundaries, since they are strictly defined. You can always change or extend them as needed but it is a very intention change. If your team is big enough those contracts could even have different code owners who might have an opinion on changing the contract.</p>"},{"location":"learnings/2024-09-29-modules/#scaled-out","title":"Scaled out","text":"<p>You won't be able to avoid the spiderweb that will become your module dependency graph, but using this technique your modules will remain lightweight. You will need to ensure all dependencies on the contract modules are contracts or external dependencies, or you won't benefit from the build cache benefits. If you have existing modules already you should attempt to create a contract for them and dereference them, or refactor the module altogether.</p> <p> </p>"},{"location":"learnings/2024-09-29-modules/#implementation-details","title":"Implementation details","text":"<p>Contract modules can comprise of interfaces, data classes, enum/sealed classes, and constants. Implementations can be bound to the implementations via dependency injection, preferably using Hilt. You can even abstract away entire experiences behind a contract and simply launch them via interface. Edge cases like reusable views should probably be standalone modules only used by implementations, but keep it tightly scoped or it quickly can get out of hand.</p>"},{"location":"learnings/2024-09-29-modules/#references","title":"References","text":"<ul> <li>Solid Modularization - Untangling the dependency graph</li> <li>Android at Scale (with Circuit)</li> </ul>"},{"location":"projects/2019-03-05-ipa/","title":"Ingress Personal Assistant","text":"<p> Java \u2002 620 commits \u2002 Last commit on Sep 16th, 2014</p>"},{"location":"projects/2019-03-05-ipa/#overview","title":"Overview","text":"<p>IPA is a third party client for the mobile game Ingress. It was purely designed to be used for allowing additional functionality and behaviors that is directly against the core ideals of the game. This undetectable cheating client was not widely known about and was held in private use only.</p>"},{"location":"projects/2019-03-05-ipa/#map-overview","title":"Map Overview","text":"<p>This feature is arguably the most important feature of the app. It allowed me to see and interact with the game without use of the game client itself. First and foremost I was able to directly set my location within the game for any later actions. Support for automatic drifting and speed limit detections were in place and could not be overridden.</p> <p>Using this feature in practice allowed for knowing the current game state in any location and acting upon that information from any number of linked accounts. All basic features for interacting with the environment were mirrored from the official client but would use the current set position.</p> <p>This experience was built by replicating the network responses of the official Ingress Intel Map and storing known good data in a local database. That known data is then overlaid on top of a native Google Maps display within the client.</p>"},{"location":"projects/2019-03-05-ipa/#inventory-viewer","title":"Inventory Viewer","text":"<p>  Ingress has this concept of acquiring new items by \"hacking\" the points of interest called \"portals\". Typically you do this in a limited way because you need to physically be at those locations and it is hard to acquire mass quantities of items. They also have a client side limit on the total amount of items so the official app doesn't let you get a ton at a time.</p> <p>Leveraging the map feature I could access those portals at any time so I found my inventory space being maxed out very quickly. At the time it was very difficult to drop or recycle multiple items simultaneously so I added this viewer to allow me to quickly do so with a few clicks. Later on the authors of Ingress added the ability to recycle them natively.</p> <p>This was all made possible by intercepting the network requests of the native Android Ingress client and replicating them. This is a drastic simplification of the process.</p>"},{"location":"projects/2019-03-05-ipa/#automation","title":"Automation","text":"<p>  Arguably the most fun part of the game is the ability to build and destroy things with a group of people. Using this client cuts out that entirely since you physically don't need to go to those locations. So I wanted to augment my normal play with teammates by giving myself essentially unlimited gear.</p> <p>Using the known locations of all portals in an area I was able to build a shortest path route to them all. Leveraging the automatic drift and speed limit protections I was able to safely navigate to all locations and harvest massive quantities of items. To eliminate the problem of running out of inventory space I built a simple algorithm that would clean up unwanted items if I hit a set threshold.</p> <p>I was able to get hundreds of thousands of items this way and it was completely undetectable to all other players around me. I could go in person and play without any limitations or restrictions on what items I would use since I could get more at any time.</p>"},{"location":"projects/2019-03-05-ipa/#black-hole","title":"Black Hole","text":"<p>  Users are required to use a specific amount of energy to do any action that interacts with portals throughout the game. This energy is called XM and is randomly distributed throughout the game and pools around portals themselves. It is visibly seen on the in-game map and the only other way of acquiring it is to recycle your items for a limited amount in return.</p> <p>Upon finding out that the specific network response that consumes that XM from around the player doesn't actually validate correctly I started abusing it. I look for all XM around the player's location within a set distance and consume it all. Once the players XM limit has been reached it essentially destroys the XM. This was abused to destroy all XM in an area so opponents can't use this to their advantage.</p> <p>I learned later that this was even more broken. The unique identifiers for the XM themselves were never validated and could be repeated for infinite untraceable XM.</p>"},{"location":"projects/2019-03-07-movies-tv/","title":"Movies & TV","text":"<p> Java \u2002 471 commits \u2002 Last commit on Nov 7th, 2015</p>"},{"location":"projects/2019-03-07-movies-tv/#overview","title":"Overview","text":"<p>This application was an alternative client to the Android application Showbox. Showbox is an application that allows streaming of free movies and television shows. At the time it didn't allow for downloading of content and was filled with advertisements. My client allowed for direct streaming of their pirated content without advertisements with a clean and simple user interface. This application was in active development from October 2014 until November 2015.</p> <p> </p>"},{"location":"projects/2019-03-07-movies-tv/#show-data","title":"Show data","text":"<p>The way that Showbox managed their data at the time was by providing datablobs in the form of a zip file with json files embedded. It included information on the shows, categories, and recently added. <pre><code>data_en.zip\n  /movies_lite.json\n  /tv_lite.json\n  /cats.json\n  /news_movies.json\n  /news_tv.json\n</code></pre></p> <p>Since the domain that was hosting this data was taken down over time (I saw this happen at least once) they had remote configuration in place to allow for swapping the download location. I copied this behavior and added my own parsing to normalize all of their data so I can easily query from it. Using TheMovieDB's api I backfilled any other missing required data.</p>"},{"location":"projects/2019-03-07-movies-tv/#stream-links","title":"Stream links","text":"<p>At the time of development Showbox used the Russian Facebook alternative VK as their backing video source. Using rolling accounts they would upload content and if it went down the client would notify them it needed to be re-uploaded. Every show had a unique identifier specific to Showbox and using it you could query their api for information on the available streaming links. The problem is that it would simply return a list of hashes.</p> <p>This hash could only be interpreted by using the native library embedded within the Showbox application itself along with using their own package name and a secret key. All of this was useless when you can simply import their own native libraries, use a ContextWrapper to fake your package name, and copy the plaintext secret.</p> <pre><code>new ContextWrapper(context) {\n\n    @Override\n    public String getPackageName() {\n        return \"com.tdo.showbox\";\n    }\n};\n</code></pre> <p>Using this parsed hash I could generate a good url and attempt to request all available qualities. Most of the time this would work fine but in the case that it didn't I simply notified Showbox that the upload failed like the real client. I knew what they were doing mostly by using a proxy on the host device but learning how and why was the difficult part. <pre><code>String[] parts = hash.split(\":\");\nif (parts.length &gt;= 2) {\n    long magic = seriesId + season + episode;\n    long id = magic + Long.valueOf(parts[0]);\n    long oid = magic + Long.valueOf(parts[1]);\n\n    Map&lt;MovieDetail.Quality, String&gt; videoUrls = getVideoUrls(\"http://m.vk.com/video\" + id + \"_\" + oid);\n    detail.setVideoUrls(videoUrls);\n    detail.setQualities(new ArrayList&lt;&gt;(videoUrls.keySet()));\n}\n</code></pre></p>"},{"location":"projects/2019-03-08-tweedle/","title":"Tweedle for Twitter","text":"<p> Java \u2002 3,818 commits \u2002 Last commit on Sep 15th, 2017</p>"},{"location":"projects/2019-03-08-tweedle/#overview","title":"Overview","text":"<p>Tweedle is a consumer facing custom Twitter client. Throughout it's lifetime it achieved over 825k downloads, 15k reviews, and maintained an average rating of 4.2. Development started August 2011 and continued until October 2014.</p> <p> </p>"},{"location":"projects/2019-03-08-tweedle/#pros","title":"Pros","text":"<p>Tweedle hands down has been my most successful individual project. It allowed me to interact and learn directly from my customers and taught me many valuable lessons that couldn't have been learned otherwise. One of my most proud moments was seeing it featured under 'Staff Picks' on Google Play.</p> <p> </p> <p>I used Tweedle as a tool to allow me to learn new technologies and push the boundaries of what we expect from an application. As an example after the release of the Androidify application the team that developed it released a library called svg-android. This was the first time we had solid example of using SVGs on the Android platform. I used this library after converting all of my assets to SVGs and built a dynamic theming framework that allowed my users to customize their theme indefinitely.</p> <p>Features like this and a heavy push from the Twitter community drove the word of mouth popularity of the product. It never achieved a huge presence on the platforms biggest blogs or forums but that didn't stop it from growing continuously until the end.</p>"},{"location":"projects/2019-03-08-tweedle/#cons","title":"Cons","text":"<p>Building an application used actively by tens of thousands of people is stressful to say the least. I had no buffer between me and hundreds of emails and tweets a day. This is entirely my own fault but it does take a toll on you. When the project ended it burnt me out on the Twitter platform as a whole.</p> <p>I have mentioned multiple times that the project ended but not why. The same week that we were featured on Google Play Twitter made an announcement that moving forward all api consumers are now limited to 100k tokens unless authorized by Twitter themselves. I immediately reached out to Twitter for information on getting authorized and never received a response.</p> <p>I carefully built in safeguards to allow for users to manually override my access tokens if my official ones were revoked for any reason and continued development. Eventually we hit a point where Twitter stopped allowing new users to authenticate and I unpublished the application.</p>"},{"location":"projects/2019-03-09-progress/","title":"Progress","text":"<p> Kotlin \u2002 470 commits \u2002 Last commit on Dec 3rd, 2023</p>"},{"location":"projects/2019-03-09-progress/#overview","title":"Overview","text":"<p>Progress is a simple fitness tracker for managing your weight, calories, and water intake. This project is made of both an Android client written in Kotlin along with a server component written in Java. This project was publicly available through the Google Play Store from June 2018 until August 2024.</p> <p> </p>"},{"location":"projects/2019-03-09-progress/#dependency-breakdown","title":"Dependency Breakdown","text":"<ul> <li>RxJava</li> <li>Dagger</li> <li>Jackson</li> <li>OkHttp</li> <li>Otto</li> <li>HelloCharts</li> <li>Timber</li> <li>Mockito</li> <li>ANR-Watchdog</li> <li>Firebase</li> <li>Licenser</li> </ul>"},{"location":"projects/2019-03-09-progress/#android-project-design","title":"Android Project Design","text":"<p>The architecture of this project was designed off of the Clean Architecture and MVP patterns. From a high level it is designed to allow decoupling of responsibility for ease of maintainability and testing purposes. An earlier pre-Kotlin version of such design can be found broken down in detail here.</p> <p> </p> <p>Code structure alone will not allow you to see the benefits of this pattern. Specific hard and fast rules are in place at a design guideline level to keep everything properly decoupled.</p> <ul> <li>All entities will be immutable.</li> <li>All interactors will be the most ideal interface for requesting the associated entity.</li> <li>All presenters will know nothing of Android.</li> <li>All view interactions (clicks/visibility changes/ect.) will be triggered from a presenter.</li> </ul> <p></p> <p></p>"},{"location":"projects/2019-03-09-progress/#server-project-design","title":"Server Project Design","text":"<p>This server component was my first example of using the Spring framework in a production environment. Since the userbase of this project is still in the single digits scaling wasn't much of a concern so using a simple SQLite JDBC integration for the backend data made perfect sense. Authentication via any number of social or even anonymous sources is handled by Google's Firebase platform.</p> <p>This setup is all configured in Docker and ran off a Digital Ocean Droplet. Network requests are filtered through CloudFlare to protect us from any denial of service attacks. Since our data is not being handled in any distributed manor we have automatic backups configured to export directly to Amazon S3 Glacier.</p> <p>Since initial deployment we have had three outages but they were only caused by the underlying hardware on Digital Ocean requiring a reboot and caused no issues. Our average median response time over the last six months is 160ms.</p>"},{"location":"projects/2022-11-26-busted/","title":"Busted","text":"<p> Kotlin \u2002 484 commits \u2002 Last commit on Aug 24th, 2024</p>"},{"location":"projects/2022-11-26-busted/#overview","title":"Overview","text":"<p>Busted is a platform that I have been developing casually since 2017. It's purpose is to coordinate with the many different independent services I have running on my network and provide detailed information on the current state of things. Additionally whenever a manual action needs to be taken for maintenance, it will coordinate those actions. For example, I could display a list of running Docker containers in a mobile app and if one container is reporting a status check failure I could restart it from anywhere in the world with a simple click.</p>"},{"location":"projects/2022-11-26-busted/#backend","title":"Backend","text":"<p>Building out all of this has been an iterative process. Initially this was where I got my feet wet with spinning up a Docker container for hosting my media server in a more portable way. Then once that was up and running I added more services that complimented the media server and eventually my own services to provide custom behavior.</p> <p>The first and most long running service is the foundation to the Busted platform, the Busted API. It is built leveraging the Spring framework to provide a nice interfacing layer for coordinating with my other services. Since they can and do have vastly different API implementations I felt that rolling my own layer here could allow me to isolate that adaption into one place and even more importantly, isolate those services from the outside world.</p>"},{"location":"projects/2022-11-26-busted/#frontend","title":"Frontend","text":"<p>Since this is an internal tool and Android has been my platform of choice for a decade I decided to build out the frontend for it alone. With the API being stable Busted could be used for testing out other platforms in the future, but for now this is it.</p>"},{"location":"projects/2022-11-26-busted/#busted-10","title":"Busted 1.0","text":"<p>The first iteration of the Android client was built in Java, leveraging the MVP design pattern. It was implemented using the common tools of trade at the time of RxJava2, Dagger, and Butterknife. The design took inspiration from some of my previous internal projects but it was all pretty cut and dry, I wasn't trying to win any design awards here. Below are some screenshots from the client.</p> <p> </p>"},{"location":"projects/2022-11-26-busted/#busted-20","title":"Busted 2.0","text":"<p>Normally I'm not one to rewrite something just because it is using old patterns or technology, but this time is a bit different. The last few years Google has been pushing their new layout system Jetpack Compose pretty hard. Those who use it cast aside the old ways like they are inferior and I am susceptible to a little bit of fear of missing out from time to time. So I decided to dip my toes into it by diving headfirst into the deep end with no flotation device. With everyone I knew that knows Compose on holiday, I loaded up Android Studio and created a new project.</p> <p>The first step I decided to do was document my existing Busted API using an OpenAPI 3.0 config and generate a client integration via SwaggerHub. This provided an honestly bad implementation to interface with but so far it has been functional enough that I have not bothered to write my own yet. With a couple wrapper classes I could hide away their bad auto-generated code. After configuring authentication I was effectively ready to start building out my user interface.</p> <p>Building with Compose overall is frustrating</p> <p>All of the institutional knowledge that we have obtained for building user interfaces can largely be thrown out. Components are named just different enough that they are unintuitive, and some things are named the same but can act differently depending on the context or even order of operations. For example, margin and padding back in the xml layout system had clear and defined behaviors. Both of those concepts are now combined into simply padding and depending on if you add a background before or after you set the padding it will display differently.</p> <p>I based my Compose integration upon the JetNews sample provided by Google and leveraged M3 components. At this point in time this is the absolute bleeding edge of what they recommend. Building out all of the top level sections I was able to fully immerse myself into the new layout system. I have a single Activity + ViewModel design with multiple sections all backed by a single state representing my view layer. Coordinating side effects like dialogs and snackbars can be a bit convoluted but that is what you get when you have a single state generating everything.</p> <p>This exercise was a good one, but I don't think this is the final iteration of the layout system. As the system matures over time we will be able to build amazing things with it. I will not be casting the xml layout system aside for now, but for non-production code I will also be using Compose. I still have quite a bit of work left to go on this project alone.</p> <p> </p> <p> </p>"},{"location":"projects/2024-09-17-mangaloid/","title":"Mangaloid","text":"<p> Kotlin \u2002 361 commits \u2002 Last commit on Sep 15th, 2024</p>"},{"location":"projects/2024-09-17-mangaloid/#prelude","title":"Prelude","text":"<p>January 13th, 2024 was the day the Tachiyomi project ended. Tachiyomi was an open-source Android application for downloading and reading manga, webtoons, and comics. The base project only supported the reading experience alongside support for extensions to download content. The extension implementations were a separate community driven project and largely were the primary way that users downloaded their content to be viewed within Tachiyomi. When the projects were paired together it was a seamless experience.</p>"},{"location":"projects/2024-09-17-mangaloid/#what-now","title":"What now?","text":"<p>In the aftermath of Tachiyomi ending I (along with most of the community) looked for alternatives. Quite a few forks of the base project and extensions popped up but without the community coming together to support them in a unified manor, it was doubtful if they would succeed. After auditing all options I assessed that the base Tachiyomi project itself is relatively stable and doesn't need to be changed that often; the bigger problem is the extensions.</p> <p>Extensions for Tachiyomi provide a source for searching and downloading content from a specific site. Traditionally this is done by either scraping the website and downloading the content or by accessing the content via a dedicated api exposed by the site. This abstraction allows the user to choose what to download and where from.</p>"},{"location":"projects/2024-09-17-mangaloid/#option-1-supporting-the-existing-implementation","title":"Option 1: Supporting the existing implementation","text":"<p>In the past I had built my own extension for a web comic I was reading, so I am accustomed to the overall structure of an extension. Looking at the code for a couple sites I normally download from though showcased a wide array of different kinds of implementations. It would be difficult to long term support this by myself, even if I dropped the sites I don't need. This would also inherit a pain point encountered from time to time: extensions breaking due to website or Cloudflare changes. When this happens you are unable to read any content not downloaded. This encourages users to download a bunch of content at once, increasing the load on the sites.</p>"},{"location":"projects/2024-09-17-mangaloid/#option-2-writing-my-own","title":"Option 2: Writing my own","text":"<p>Taking a step back from the existing implementation I looked at the problem as a whole. Scraping websites and extracting content is a solved problem. At the scale that Tachiyomi was doing it effectively it was crushing the sites like a distributed attack constantly. It doesn't need to be this way for my own project because I don't plan on distributing it at all. We could in theory just have a web service occasionally poll the sites and only download what we need. The service becomes the source of truth and even if my scraping code breaks, I have access to the backlog of content. Even if the latest is unavailable until I fix the broken scraper. The initial sync will be intensive, but compared to Tachiyomi it will be nothing.</p> <p>This sounded promising so I investigated how I could integrate this theoretical web scraping service into an extension. Although I could write this myself, along with extracting data from the soon-to-be downloaded files: this is also a solved problem. I came across a project called Komga, it not only can serve locally hosted content but also happens to already have a Tachiyomi extension. This in theory could solve the other half of the problem for me. The only major risk in relying upon this project is if they drop support for their extension long term, but that is a problem for future me who loves taking on those kinds of surprise challenges.</p>"},{"location":"projects/2024-09-17-mangaloid/#mangaloid","title":"Mangaloid","text":"<p>Ultimately I decided upon Option 2, the service soon to be named Mangaloid. Realistically it wasn't that simple though. I did review a few existing tools that could do different parts of the job, but the closest I could find was one called mangal. This tool could do all the web scraping, but was all configured in Lua. I was not comfortable jumping into that codebase with minimal experience in web scraping and Lua, which I have not touched since the PSP was king.</p>"},{"location":"projects/2024-09-17-mangaloid/#web-scraping","title":"Web scraping","text":"<p>Previously with projects like Progress and Busted I have leveraged the Spring framework in Java or Kotlin for spinning up web services. This would allow me to easily write tests and utilize patterns I have used for years. This would also allow me to utilize my JSoup experience from Tweedle, but realistically I have not touched that in years. In the end I threw out all of that sane decision making and wrote it in Python with BeautifulSoup as the core.</p>"},{"location":"projects/2024-09-17-mangaloid/#cloudflare","title":"Cloudflare","text":"<p>One of the biggest challenges in web scraping is trying to bypass Cloudflare protections. They are typically in place to deter bots and denial of service attacks. This adds an extra layer of security to any website (for a price) to ensure malicious actors are not misusing your website.</p> <p>FlareSolverr acts as a proxy that can attempt to bypass all of those protections. It is updated semi-regularly and has a large community of users using it to enable their web scrapers. This is used to scrap all sorts of websites and is supported by many tools as a built in option if you self host it. It isn't perfect, but it is better than just switching your headers and hoping for the best like with Tachiyomi.</p>"},{"location":"projects/2024-09-17-mangaloid/#komga","title":"Komga","text":"<p>The last piece of the puzzle was understanding how the data should be formatted on disk. After reviewing all of the documentation I could find and testing out a few options I ended up on the following format:</p> <pre><code>Library/Series/cover.jpg\nLibrary/Series/mangaloid.json\nLibrary/Series/series.json\nLibrary/Series/Chapter 1.cbz\n                    /0.jpg\n                    /...\n                    /190.jpg\n                    /ComicInfo.xml\nLibrary/Series/...\nLibrary/Series/Chapter 203.cbz\n</code></pre> <p>The library and series paths are pretty self explanatory. Stepping into the series folder we want to be able to display a cover image for the whole series, along with metadata and the chapters themselves. The structure of mangaloid.json is custom and provides the information I need about the source site, how often we should refresh, and when we last refreshed. The series.json file is a standard metadata format from mylar.</p> <p>Looking at the cbz file, it is a standard comic book zip archive format. The variant used here includes the images along with a ComicInfo.xml file per chapter. A now defunct comic book downloader named ComicRack pioneered this format and was so popular that it now lives on beyond the downloader with community driven support.</p> <p>With all of this figured out I formatted the files carefully within the correct directories, and would leverage Komga's api to refresh the metadata on their side. This updates the index and within no time I am able to see the latest content within Tachiyomi.</p>"},{"location":"projects/2024-09-17-mangaloid/#android","title":"Android","text":"<p>With all of the pieces coming together, I wanted to be able to be able to check the status of things without directly checking the docker output logs. Taking my time I went through options like Flutter and .NET but ultimately came back to my roots and wrote it in Android via Compose. Using a simple api I was able to display the currently monitored series, update the refresh interval, and manually trigger a refresh. Eventually this would become more feature rich, but that took a long time to backfill.</p>"},{"location":"projects/2024-09-17-mangaloid/#final-thoughts","title":"Final thoughts","text":"<p>This project has been a blast to write. Building out systems like this is really fun and allows me to stretch myself out into areas I previously took for granted. Even in writing this all out I see now where I can improve in the future to make better decisions moving forward. If only I could fix that one pesky website failing Flaresolverr randomly...</p>"},{"location":"projects/2024-09-17-mangaloid/#mangaloid-v2","title":"Mangaloid v2","text":"<p>I was a bit optimistic and vague earlier when describing how I would work around Cloudflare. Flaresolverr ended up not being as stable as I wanted. Some websites had some pretty tough anti-bot code to work through. Lastly, using things like Python's requests library out of the box will never be robust enough for sites that know you are going to scrap them. It just isn't good enough to get through fingerprint checks.</p>"},{"location":"projects/2024-09-17-mangaloid/#web-traffic-fingerprint-queue","title":"Web traffic fingerprint queue","text":"<p>After six months of dealing with Flaresolverr breaking randomly and following the various issue trackers, I wanted to see if I could work around them sometimes just not being reliable. I would prefer that the service would run autonomously and I wouldn't need to constantly keep an eye on it like a pet. Wouldn't it be nice if I could just manually click the box and bypass captcha if it was broken like a mechanical turk?</p> <p>In theory if I could refactor the implementation so that I no longer directly rely upon things like Flaresolverr, I could swap it out with other options. It could be one of the many forks of Flaresolverr, or something wild like an Android application that directly loads the content into a WebView and pipes the content back like a proxy. This would allow me to experiment with different options without needing to rewrite my whole codebase.</p> <p> </p>"},{"location":"projects/2024-09-17-mangaloid/#rewriting-the-whole-codebase","title":"Rewriting the whole codebase","text":"<p>Although my first pass at this was written in Python, I didn't think adding this kind of abstraction would be the best idea on that codebase. I am far more comfortable with Kotlin and frankly the fact that Python uses blank lines as function and class definitions was driving me mad.</p> <p>I wrote out my initial draft of the queue implementation, and got to work recreating my web scraper in Kotlin using Ktor and JSoup. Getting the existing api contract up and running using Ktor was really simple, even though it was my first time using the framework. I have used JSoup before, but not with the level of detail needed for this project. In the end, css queries were the MVP and serve as the backbone of the project.</p> <p>I ended up writing three different Daemon (request handler) implementations. The first one was for Flaresolverr, the second was for MITM proxy, and lastly an Android client for proxying manually if things ever broke. I have some other options as well that I might try, a browser plugin could be nice for example. The idea around this framework is I should be able to adapt it to pretty much any tool if needed to ensure it keeps on working as intended.</p>"},{"location":"projects/2024-09-17-mangaloid/#final-thoughts_1","title":"Final thoughts","text":"<p>So far this latest iteration of Mangaloid is stable and from my perspective maintainable. Time will tell if that holds true. I'll learn eventually if some of my gambles with things like Komga were worth it. Worst case I can always write my own extension, but that is a problem for future me.</p>"}]}